!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   CARACAL - Ring polymer molecular dynamics and rate constant calculations
!             on black-box generated potential energy surfaces
!
!   Copyright (c) 2023 by Julien Steffen (mail@j-steffen.org)
!                         Stefan Grimme (grimme@thch.uni-bonn.de) (QMDFF code)
!
!   Permission is hereby granted, free of charge, to any person obtaining a
!   copy of this software and associated documentation files (the "Software"),
!   to deal in the Software without restriction, including without limitation
!   the rights to use, copy, modify, merge, publish, distribute, sublicense,
!   and/or sell copies of the Software, and to permit persons to whom the
!   Software is furnished to do so, subject to the following conditions:
!
!   The above copyright notice and this permission notice shall be included in
!   all copies or substantial portions of the Software.
!
!   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
!   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
!   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
!   DEALINGS IN THE SOFTWARE.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!
!     #################################################################
!     ##                                                             ##
!     ##  program calc_rate  --  sampling and k(T) calculations      ##
!     ##                                                             ##
!     #################################################################
!
!     "calc_rate" performs Umbrella samplings and recrossing calculations 
!     for a distinct elementary reaction and calculates the k(T) value 
!     from the free energy surface generated by WHAM/Umbrella-integration
!     
!     Call the program with: mpirun -np [nproc] ~/bin/calc_rate.x
!
!
!     Disclaimer (general structure/idea and code snippets taken from):
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     
!   RPMDrate - Bimolecular reaction rates via ring polymer molecular dynamics
!     
!   Copyright (c) 2012 by Joshua W. Allen (jwallen@mit.edu)
!                         William H. Green (whgreen@mit.edu)
!                         Yury V. Suleimanov (ysuleyma@mit.edu, ysuleyma@princeton.edu)
!
!   Permission is hereby granted, free of charge, to any person obtaining a
!   copy of this software and associated documentation files (the "Software"),
!   to deal in the Software without restriction, including without limitation
!   the rights to use, copy, modify, merge, publish, distribute, sublicense,
!   and/or sell copies of the Software, and to permit persons to whom the
!   Software is furnished to do so, subject to the following conditions:
!  
!   The above copyright notice and this permission notice shall be included in
!   all copies or substantial portions of the Software.
!
!   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
!   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
!   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
!   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
!   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
!   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
!   DEALINGS IN THE SOFTWARE.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
program calc_rate
use general
use evb_mod
use pbc_mod
use debug
use qmdff
implicit none
!
!     include MPI library
!
include 'mpif.h'
integer::i,istep,gen_step,equi_step,umbr_step
integer::asciinum,j,k,l,nat,p
integer::mode,next,check,readstatus
integer::qmdffnumber
integer::readstat,openstat
!     the timestep for calculation and write out
real(kind=8)::dt,dtdump
!     timestep for information of user 
real(kind=8)::dt_info
real(kind=8),dimension(:),allocatable::int_coord  ! for internal coordinates
real(kind=8),dimension(:,:),allocatable::xyz2
logical exist,query
character(len=1)::qmdffnum
!     the evb-qmdff input
character(len=70)::fffile1,fffile2,fffile3,fileinfo,filets
character(len=70)::filets2
logical::exists,has_next
logical::evb1,evb2,evb3,ffname1,ffname2,ffname3,defqmdff
logical::path_struc,path_energy,coupl,ts_xyz,params
!     for Umbrella sampling
real(kind=8),dimension(:,:,:),allocatable::derivs  ! the derivatives of the potential 
                                             !   energy for all beads at once
logical::run_finished  ! if the sampling was already finished before..
character(len=80)::a80,names
integer::num_lines,lastline 
integer::num_struc
character(len=70)::filegeo
real(kind=8),dimension(:),allocatable::int_curr
real(kind=8)::xi_val_test  ! for reading in of individual umbrella force constants
real(kind=8)::xi_val   ! the (ideal) xi value for this umbrella window
real(kind=8)::xi_real  ! the actual sampled xi value in the verlet algorithm
integer::n_all ! total number of sampling windows
character(len=50)::temp_name,bead_name
character(len=50)::foldername,subfname,subsubfname
logical::oldfolder,dont_del,dont_equi,dont_umbr
real(kind=8),dimension(:),allocatable::xi_wins ! auxiliary array for all xi ref values
!     for PMF calculation (general)
integer::nbeads_store   ! the stored number of beads for the umbrella sampling
real(kind=8)::xi_min,xi_max,bin_size
integer::nbins,act_entry
integer::num_umbrella  ! total number of umbrella windows to be sampled
real(kind=8),dimension(:),allocatable::bin_entries  ! number of hits for each bin (WHAM)
real(kind=8),dimension(:,:),allocatable::all_bin_entries  ! array with all xi-distibutions
real(kind=8)::rdummy ! dummy variable for read in of coordinate columns
!     for PMF calculation (umbrella integration)
real(kind=8),allocatable::p_ib(:),dA_iu(:) ! normal distributions for windows
real(kind=8),allocatable::dA(:)  ! derivative of the PMF curve in all bins
real(kind=8)::k_B ! inverse temperature and boltzmann constant
real(kind=8)::xi_act,denom ! for calculations of bin distributions
real(kind=8)::A_act  ! the actual integrated free energy
real(kind=8),allocatable::pmf(:)   ! array with all free energies on path
real(kind=8),allocatable::pmf_wham(:)  ! array with all free energies calculated with WHAM
real(kind=8)::dx  !  width for numerical integration
real(kind=8),allocatable::bin_coord(:)  ! xi coordinates for the bin entries
real(kind=8),allocatable::bin_tmp(:)  ! temporary xi coordinates - xi_max diff array
real(kind=8),allocatable::xi_tmp(:)  ! temporar xi coordinates for recross parent selection
parameter(k_B=3.16681517576e-06)  ! the boltzmann constant in au/kelvin
real(kind=8)::print_poly  ! position along the reaction path for which an umbrella 
                          ! trajectory shall be printed out
logical::active ! for testing of read in lines
logical::do_presamp   ! if the pre sampling shall be activated
character(len=80)::ts_file ! filename of the ts structure (the starting point!)
integer::istat ! check if an integer has been read in correctly
integer::n_presample   ! number of structures to be presampled
integer::ts_locate   ! index of the recrossing TS within the umbrella equi array
real(kind=8)::xi_ideal   ! dummy for calc_xi call
real(kind=8)::centom(3)  ! center of masses of preequilized structures
real(kind=8)::average_act,variance_act   ! actual values of average and variance for this traj.
real(kind=8)::pmf_int  ! integral of PMF profile for unimolecular reactions
!     for VASP input from POSCAR
character(len=1)::check_sel
integer::ind
character(len=100)::string
real(kind=8)::x_tmp,y_tmp,z_tmp
!     for recrossing calculation
integer::pmf_maxlocate,maxlocate,minlocate  ! the bin in which the PMF has its maximum/minimum
real(kind=8)::xi_barrier,xi_pmf_max,xi_minimum  ! the xi-value at which the PMF is maximal/minimal
real(kind=8)::kappa  ! the final recrossing coefficient
!     for k(T) calculation
character(len=10)::pmf_minloc
real(kind=8)::pmf_max,pmf_min  ! the minimum and maximum of the PMF
!     for MPI parallelization
logical::recross_mpi   ! if recrossing shall be calculated in parallel or serial
integer::ierr,ID,impi_error
integer::psize,rank,source,status(MPI_STATUS_SIZE)
integer::count,tag_mpi,dest,message
integer::maxwork,numwork
!     times
integer::tot_time,ndays,nhours,nminutes,nseconds
!     for first umbrella sampling step
real(kind=8),dimension(:,:),allocatable::derivs_1d,q_1b
real(kind=8)::epot
!     how many trajectory errors can occur before termination
integer::err_count,err_act
integer::struc_reset  ! how often the start structure was already changed in this trajectory
integer::traj_error ! if an error occured or not
integer::gen_reset  ! complete resets of start structure generations
integer::reset_prob  ! after how many steps a reset should occur, fraction of err_max
real(kind=8)::energy_ts,energ,energy_act ! energy of the TS and the actual energy, check if current 
real(kind=8),dimension(:),allocatable::equi_energy               ! energies of equilibrated structures
real(kind=8)::average_store,variance_store ! backup values for averages,variances
character(len=4)::rank_char  ! for separate folders of MPI ranks (call external)
!     for debug reasons
integer::gnu_xi_unit  ! for optional plot of Xi distributions
integer::xi_real_unit  ! for print of real Xi values for umbrella start structures
real(kind=8),dimension(:,:),allocatable::coord
real(kind=8),dimension(:),allocatable::int_act
real(kind=8),dimension(:),allocatable::start_xis  ! xi values of start structures for umbrella
real(kind=8),dimension(:,:,:),allocatable::pre_equi   ! pre equilibr. structures 
real(kind=8),allocatable::q_i_save(:,:,:)  ! backup array if coordinates are destroyed
real(kind=8)::s0,s1  ! values for xi calculation in bimolec
real(kind=8),allocatable::dxi_act(:,:) ! the calculated Xi derivative
real(kind=8),allocatable::d2xi_act(:,:,:,:)  ! the calculated Xi hessian
character(len=40)::commarg ! string for command line argument
character(len=120)::adum
!real(kind=8)::pi  ! the pi

!pi=3.141592653589793238462643d0

!
!     Start MPI parallel computation:
!     Since the whole program is executed by all processes, all "serial"
!     parts will be executed only by processor #0
!
call mpi_init(ierr)
call mpi_comm_size(mpi_comm_world,psize,ierr)
call mpi_comm_rank(mpi_comm_world,rank,ierr)
err_count=0
err_max=1000  ! how many trajectory errors should occur before termination
reset_prob=100  ! after how many steps a reset should occur, fraction of err_max
err_act=0 ! errors per actual sampling
err_act_max=10  ! maximal number of errors per actual sampling, before other start
                ! structure will be taken
!
!    Measure the needed time for initialization of the system
!
if (rank .eq. 0) then
   call cpu_time(time(1))
end if
call mpi_barrier(mpi_comm_world,ierr)
!
!     Open a logfile in which all informations that are printed 
!     to screen and additional informations will be stored!
!

open(unit=15,file="calc_rate.log",status="unknown")
if (rank .eq. 0) then
   call promo_log(15)
end if
!
!     MPI is used
!
use_mpi=.true. 
!
!     No recrossing will be done in the first steps..
!
recross_calc=.false.
!
!     The program calc_rate is used: needed for PES setup of external PES
!
use_calc_rate=.true.
!
!     The explore program is not used
!
use_explore = .false.
!
!     No frequency intensities as default
!
calc_freq_int = .false.

!
!     set up the structure and molecular mechanics calculation
!
call prog_initial(rank)
!
!     print out help informations if -help or -h is given as command line argument
!     call the respective subroutine, else, show infos about the possibility
!
if (rank .eq. 0) then
   call get_command_argument(1, commarg)
   if (trim(commarg) .eq. "-help" .or. trim(commarg) .eq. "-h") then
      call help("calc_rate")
      stop
   else
      write(*,*) "To show some basic infos about the program and a list of all"
      write(*,*) "used keywords in it, type 'rpmd.x -help' or 'rpmd.x -h'."
   end if
end if
!
!     Read keywords from the key-file
!
call getkey(rank)

!
!     print general program information
!
if (rank .eq. 0) then
   write(15,*) "You have ordered a rate constant calculation with evb_qmdff!"
   write(15,*) "This will be done utilizing the Bennett-Chandler factorization"
   write(15,*) "of the QTST rate constant!"
   write(15,*) 
   write(15,*) "initiation time:"
   call timestamp () 
   write(15,*) 
   write(*,*) "You have ordered a rate constant calculation with evb_qmdff!"
   write(*,*) "This will be done utilizing the Bennett-Chandler factorization"
   write(*,*) "of the QTST rate constant!"
   write(*,*)
end if


!
!     Read in settings for the rate calculation
!
use_rpmd=.true.  ! for init_int etc
call calc_rate_read(rank,dt,dtdump,dt_info,gen_step,equi_step,umbr_step,xi_min,&
          & xi_max,pmf_min,pmf_max,nbins,pmf_minloc,print_poly,ts_file,recross_mpi)

!
!     Read in the TS structure which is always the starting point for the
!       whole calculation!
!     If the filename is POSCAR, assume a VASP POSCAR file as input
!
if (trim(ts_file) .eq. "POSCAR") then
!   write(*,*)
!   if (rank .eq. 0) then
!      write(*,*) "The geometry is given in file POSCAR. VASP format will be assumed!"
!   end if
   coord_vasp = .true.
   open (unit=31,file=ts_file,status='old')
   read(31,*)
   read(31,*) vasp_scale
   read(31,*) vasp_a_vec
   read(31,*) vasp_b_vec
   read(31,*) vasp_c_vec
   vasp_names="XX"
!
!     Read the elements for all atoms
!
   read(31,'(a)') string
   read(string,*,iostat=readstat) vasp_names
   vasp_numbers = 0
   read(31,'(a)') string
   read(string,*,iostat=readstat) vasp_numbers
   ind=0
   nelems_vasp=0
   do i=1,20
      if (vasp_names(i) .eq. "XX") exit
      nelems_vasp=nelems_vasp+1
      do j=1,vasp_numbers(i)
         ind=ind+1
         name(ind)=vasp_names(i)
         call atommass(ind)
         call upcase(name(ind))
      end do
   end do
   n=sum(vasp_numbers)
   natoms=n
   allocate(ts_ref(3,natoms))
   allocate(elem_index(natoms))
!
!    Store element indices
!
   do i=1,natoms
      call elem(name(i),elem_index(i))
   end do
!
!    Check if selective dynamics or not
!
!    Check if POSCAR has direct or cartesian coordinates
!
   vasp_selective = .false.
   vasp_direct = .false.
   fix_atoms = .false.

   read(31,'(a)') string
   if (adjustl(trim(string)) .eq. "Selective dynamics" .or. &
          & adjustl(trim(string)) .eq. "selective dynamics" .or. &
          & adjustl(trim(string)) .eq. "Selective" .or. &
          & adjustl(trim(string)) .eq. "selective" .or. &
          & adjustl(trim(string)) .eq. "Selective Dynamics" .or. &
          & adjustl(trim(string)) .eq. "Selective Dynamics") then
      vasp_selective = .true.
      fix_atoms = .true.
      if (allocated(fix_list)) deallocate(fix_list)
      allocate(fix_list(natoms))
      fix_list=0
   else
      if (adjustl(trim(string)) .eq. "direct" .or.  &
                  & adjustl(trim(string)) .eq. "Direct") then
         vasp_direct = .true.
      end if
   end if
   if (vasp_selective) then
      read(31,'(a)') string
      if (adjustl(trim(string)) .eq. "direct" .or. &
                  & adjustl(trim(string)) .eq. "Direct") then
         vasp_direct = .true.
      end if
   end if
!
!     Now read in the coordinates
!     If selective is activated, read in the first flag as well and
!     decide if the atom is active or not (no coordinate distinction!)
!     Add the indices of the fixed atoms to the fix_list array
!
   ind=0
   do i=1,natoms
      if (vasp_selective) then
         read(31,*) ts_ref(:,i),check_sel
         if (check_sel .eq. "F") then
            ind=ind+1
            fix_list(ind)=i
         end if
      else
         read(31,*) ts_ref(:,i)
      end if
!
!     If direct coordinates are given, transform the coordinates to Angstrom!
!
      if (vasp_direct) then
         x_tmp=ts_ref(1,i)
         y_tmp=ts_ref(2,i)
         z_tmp=ts_ref(3,i)
         ts_ref(1,i)=(x_tmp*vasp_a_vec(1)+y_tmp*vasp_b_vec(1)+z_tmp*vasp_c_vec(1))*vasp_scale
         ts_ref(2,i)=(x_tmp*vasp_a_vec(2)+y_tmp*vasp_b_vec(2)+z_tmp*vasp_c_vec(2))*vasp_scale
         ts_ref(3,i)=(x_tmp*vasp_a_vec(3)+y_tmp*vasp_b_vec(3)+z_tmp*vasp_c_vec(3))*vasp_scale
      end if
   end do
   if (vasp_selective) then
      fix_num=ind
   end if

   close(31)
else
   open(unit=31,file=ts_file,status="old",iostat=readstat)
   if (readstat .ne. 0) then
      if (rank .eq. 0) then
         write(*,*) "The file ",ts_file," with the start structure could not been found!"
         call fatal
      end if
   end if
   allocate(ts_ref(3,natoms))
   read(31,*) ; read(31,*)
   do i=1,natoms
      read(31,*) name(i),ts_ref(:,i)
      call atommass(i)
   end do
   close(31)
end if
!
!     Read in the information about the PES in use
!
call read_pes(rank)
!
!     convert timestep to atomic units!
!
dt_info=0.001*dt ! time in ps for information write out
dt = dt/2.41888428E-2
dtdump=dtdump/2.41888428E-2
!
!     Print general information about read in settings to logfile 
!
call calc_rate_info(rank,dt,dtdump,dt_info,gen_step,equi_step,umbr_step,xi_min,&
          & xi_max,pmf_min,pmf_max,nbins,pmf_minloc,print_poly,ts_file,recross_mpi)
!
!      define the beta parameter for thermodynamics
!
beta=1.d0/(kelvin*k_B)
!
!
!     derivatives if the internal coordinates!
!
allocate(dxi_act(3,natoms),d2xi_act(3,natoms,3,natoms))
!
!     store the number of beads during structure gen.
!
nbeads_store=nbeads
!
!      calculate how many child spwaning events will occur 
!
if ((child_tot .gt. 0) .and. (child_point .gt. 0)) then
   child_times=child_tot/child_point
end if
!     
!     Convert the energy tolerance to hartree 
!

energy_tol=energy_tol/(hartree*joule)
!
!     If only starting structures shall be generated (e.g. to test internal coordinates for 
!     the RP-EVB coupling term), open files for print out 
!
if (gen_test) then
   open(unit=295,file="gen_test_struc.xyz",status="unknown")
   open(unit=296,file="gen_test_ens.dat",status="unknown")
   write(296,*) "#       energy         s-value         z-value"
end if

!
!     If the debugging mode shall be started to print out more details!
!       give a notation here!
!
if (do_debug) then
   if (rank .eq. 0) then
      write(15,*) "You have entered the DEBUG-MODE!"
      write(15,*) "Trajectory infos will be written to debug_traj.xyz"
      write(15,*) "ATTENTION: LARGE FILE!"
      write(*,*) "You have entered the DEBUG-MODE!"
      write(*,*) "Trajectory infos will be written to debug_traj.xyz"
      write(*,*) "ATTENTION: LARGE FILE!"
   end if
   open(unit=debug_unit,file="debug_traj.xyz",status="unknown")
end if

!
!     Everything is converted to atomic units!
!
ts_ref=ts_ref/bohr 
!
!     Calculate the reference bond lengths at the TS for the s1 surface
!     only for bimolecular reactions
!
if (umbr_type .ne. "ATOM_SHIFT") then
   call bonds_ref(ts_ref)
end if
allocate(int_curr(nat6))
!
!     Convert TS to internal coordinates
!
allocate(int_ts(nat6))
call xyz_2int(ts_ref,int_ts,natoms)
!
!     Partitionate the mass to get the masses of the single reactants
!     only for bimolecular reactions
!

if (umbr_type .ne. "ATOM_SHIFT") then
   mass_reac=0.d0
   if (sum_reacs .gt. 0) then
      do i=1,sum_reacs
         do j=1,n_reac(i)
            mass_reac(i)=mass_reac(i)+mass(at_reac(i,j))
         end do
      end do
   end if
end if
!
!     initialize and setup dynamics
!     --> allocate arrays for positions (q_i) and momenta (p_i) and 
!     convert to bohr 
!
allocate(q_i(3,natoms,nbeads_store),p_i(3,natoms,nbeads_store))
allocate(q_i_save(3,natoms,nbeads_store))  ! backup array for errors
do i=1,natoms
   q_i(1,i,1)=ts_ref(1,i)
   q_i(2,i,1)=ts_ref(2,i)
   q_i(3,i,1)=ts_ref(3,i)
end do
allocate(derivs(3,natoms,nbeads))
allocate(derivs_1d(3,natoms),q_1b(3,natoms))
!
!     for RP-EVB: reallocate global arrays for storage and comparison with previous 
!     values
!
if (treq) then
   deallocate(inter_old,i_best_old)
   allocate(inter_old(nbeads,nat6))
   allocate(i_best_old(nbeads))
   inter_old=0.d0
   i_best_old=0
end if
!
!     calculate energy of the starting point; the TS (times number of beads)!
!
allocate(error_vec_ens(nat6),error_vec_v12(nat6))


!
!     If an external PES shall be used, generate a folder for each MPI rank such that
!     no problems with collisions occur
!
if (call_ext) then
   if (rank .lt. 10) then
      write(rank_char,'(i1)') rank
   else if (rank .lt. 100) then
      write(rank_char,'(i2)') rank
   else if (rank .lt. 1000) then
      write(rank_char,'(i3)') rank
   else
      write(rank_char,'(i4)') rank
   end if

   inquire(file="rank"//rank_char, exist=dont_del)
   if (.not. dont_del) then
      call system("mkdir rank"//trim(rank_char))
   end if
end if


call gradient(ts_ref,energy_ts,derivs,1,rank)
if (rank .eq. 0) then
   write(15,*)
   write(15,*) "You are starting a rate constant calculation with connected"
   write(15,*) "Umbrella-samplings"
   write(15,*)  " -.-. .- .-. .- -.-. .- .-.. "
   write(15,*)
   write(15,'(a,i2,a)') " This is a parallelized calculation, ",psize," cores are utilized."
   write(15,*)
   write(*,*)
   write(*,*) "You are starting a rate constant calculation with connected"
   write(*,*) "Umbrella-samplings"
   write(*,*)  " -.-. .- .-. .- -.-. .- .-.."
   write(*,*)
   write(*,'(a,i2,a)') " This is a parallelized calculation, ",psize," cores are utilized." 
   write(*,*) 
end if

!
!    Measure the needed time for structure generation
!
if (rank .eq. 0) then
   call cpu_time(time(2))
end if
!
!     Initiliaze the random number generator!
! 
call random_init_local(rank)
!
!     If the internal coordinates shall be written to file, open it
!
if (int_coord_plot) open(unit=191,file="int_coord.out",status="unknown")
!
! --------------------------------------------------------!
!     BEGIN THE UMBRELLA SAMPLINGS
!     FIRST START STRUCTURES FOR ALL WINDOWS
! --------------------------------------------------------!
! 
!     Loop over all windows (beginning from reactants) and geneate starting 
!     structures: take the last of the current sampling as start structure 
!     for the next!
!     Do all of these calculation with only one bead!
!    
nbeads=1
!
!     Number of single umbrella samplings:
!
n_over=nint((umbr_hi-1)/umbr_dist)
n_samplings=nint((1-umbr_lo)/umbr_dist)
n_all=nint((umbr_hi-umbr_lo)/umbr_dist)
n_all=n_all+1   ! the Zaunlatteneffekt!
if (((n_over+n_samplings)-(n_all-1)) .ne. 0) then
   if (rank .eq. 0) then
      write(*,*) "Total number of sampling windows unequal sum of windows > 1 and <= 1!"
      write(*,*) "Plase asure that the umbrella stepsize fits into the umbrella bonds!"
      call fatal
   end if
end if
!
!     Calculate the values of the umbrella bias for each window, either a 
!     constant value or read in from file
!
allocate(k_force(n_all))
if (k_force_indi) then
   open(unit=67,file=k_force_file,status="old",iostat=readstat)
   if (readstat .ne. 0) then
      if (rank .eq. 0) then
         write(*,*) "You have ordered individual umbrella force constants for all"
         write(*,*) " umbrella windows but the file ",trim(k_force_file)," with"
         write(*,*) " the force values for the windows is not there!"
         call fatal
      end if
   end if
   do i=1,n_all
      read(67,*,iostat=readstat) xi_val_test,k_force(i)
      if (readstat .ne. 0) then
         write(*,*) "The file ",trim(k_force_file)," has a wrong format on line ",i,"!"
         call fatal
      end if
      if ((xi_val_test-(umbr_lo+umbr_dist*(i-1))) .gt. 0.001) then 
         write(*,*) "The xi value for umbrella window ",i," is ", umbr_lo+umbr_dist*(i-1), " ."
         write(*,*) " You gave the xi value ",xi_val_test," for this window in the"
         write(*,*) trim(k_force_file)," file. Please check this file!"
         call fatal
      end if 
   end do
   close(67)
else
   k_force=k_force_all
end if
!     shift the umbrella force constant with temperature 
k_force=k_force*kelvin



traj_error=0    ! if trajectories give errors, abort them..
!
!     Create a folder named with simulation temperature, else, 
!
if (kelvin .lt. 10.0) then
   write(temp_name,"(i1)") int(kelvin)
else if (kelvin .lt. 100.0) then
   write(temp_name,"(i2)") int(kelvin)
else if (kelvin .lt. 1000.0) then
   write(temp_name,"(i3)") int(kelvin)
else 
   write(temp_name,"(i4)") int(kelvin)
end if

if (nbeads_store .lt. 10) then
   write(bead_name,"(i1)") nbeads_store
else if (nbeads_store .lt. 100) then
   write(bead_name,"(i2)") nbeads_store
else if (nbeads_store .lt. 1000) then
   write(bead_name,"(i3)") nbeads_store
else
   write(bead_name,"(i4)") nbeads_store
end if


foldername=trim(temp_name)//"K_"//trim(bead_name)//"bead"

inquire(file=trim(foldername), exist=oldfolder)
!
!     set this to false, else errors appear in the -02 and -03 options
!
dont_equi=.false.
dont_del=.false.
if (oldfolder) then
   inquire(file=trim(foldername)//"/current_calc", exist=dont_del)
   if (.not. dont_del) then
      if (rank .eq. 0) then
         call system("rm -r "// foldername)
         call system ("mkdir "//foldername)
      end if
   else
      if (rank .eq. 0) then 
         write(15,*) "An unfinished calculation was found in the ",trim(foldername)," folder."
         write(15,*) "We will restart the calculation from that point!"
         write(15,*) "If you want to start a completely new calculation, remove the folder first."
         write(*,*) "An unfinished calculation was found in the ",trim(foldername)," folder."
         write(*,*) "We will restart the calculation from that point!"
         write(*,*) "If you want to start a completely new calculation, remove the folder first."
         inquire(file=trim(foldername)//"/start_finished", exist=dont_equi)
      end if
   end if
else 
   if (rank .eq. 0) then
      call system ("mkdir "//foldername)
   end if
end if
call mpi_barrier(mpi_comm_world,impi_error)

call chdir(foldername)

!
!     signalize that the calculation is under way: If it is canceled before
!     the resulting folder wonÂ´t be erased!
!
call system ("touch current_calc") 
!
!     If an external PES shall be used, generate a folder for each MPI rank such that
!     no problems with collisions occur
!
call mpi_barrier(mpi_comm_world,impi_error)
if (call_ext) then
   if (rank .lt. 10) then
      write(rank_char,'(i1)') rank
   else if (rank .lt. 100) then
      write(rank_char,'(i2)') rank
   else if (rank .lt. 1000) then
      write(rank_char,'(i3)') rank
   else 
      write(rank_char,'(i4)') rank
   end if

   inquire(file="rank"//rank_char, exist=dont_del)
   if (.not. dont_del) then
      call system("mkdir rank"//trim(rank_char))
   end if
end if
!
!     in case that umbrella integration will be used, allocate arrays
!     (also when wham is active, due to small amount of work..)
!
allocate(average(n_all),variance(n_all))
average=0.d0
variance=0.d0
!
!     allocate array for Xi values of umbrella start structures (mainly for debug)
!
allocate(start_xis(n_all))
open(unit=xi_real_unit,file="xi_equi_real.dat",status="unknown")
write(xi_real_unit,*) "# These are the Xi values for the structures in equilibrated_struc.xyz"
allocate(equi_energy(n_all))
!
!     if the GLE thermostat is used, allocate its global arrays!
!
if (thermostat .eq. 1) then
   allocate(gle_S(gle_ns+1,gle_ns+1))
   allocate(gle_T(gle_ns+1,gle_ns+1))
   allocate(gle_p(3,natoms,nbeads,gle_ns+1))
   allocate(gle_np(3,natoms,nbeads,gle_ns+1))
end if

if ((.not. dont_equi) .and. (rank .eq. 0)) then
   write(*,*) 
   write(15,*) "-------------------PART   1-------------------"
   write(15,*) "Begin with first biased sampling to sample starting structures"
   write(15,*) " for upfollowing umbrella samplings.."
   write(15,*) "----------------------------------------------"
   write(*,*) "-------------------PART   1-------------------" 
   write(*,*) "Begin with first biased sampling to sample starting structures"
   write(*,*) " for upfollowing umbrella samplings.."
   write(*,*) "----------------------------------------------"
   writestat=.false.
   iout=68
   gnu_xi_unit=49
!
!     open gnuplot file for optional plotting of all Xi distributions in
!     umbrella samplings (see below)
!
   open(unit=gnu_xi_unit,file="plot_distri.gnu",status="unknown")
   write(gnu_xi_unit,*) "set title 'plot of xi distributions of samplings'"
   write(gnu_xi_unit,*) "unset key"
   write(gnu_xi_unit,*) "set xlabel 'Xi (a.u.)'"
   write(gnu_xi_unit,*) "set ylabel 'No. of hits in bin'"
   write(gnu_xi_unit,'(a)',advance="no") "plot "
!
!     First simulate the windows above xi=1.0
!
!
!     allocate array with starting structures
!
   allocate(struc_equi(n_all,3,natoms))
   allocate(xi_wins(n_all))

!
!     for possible restart of start structure generation
!
   gen_reset=1
   111 continue
   do i=1,natoms
      q_i(1,i,1)=ts_ref(1,i)
      q_i(2,i,1)=ts_ref(2,i)
      q_i(3,i,1)=ts_ref(3,i)
   end do
   do i=1,n_over
      xi_val=1+(i-1)*umbr_dist
      write(subfname,"(f6.4)") xi_val
!
!     write plot line for gnuplot file with Xi distributions during sampling
!

      write(gnu_xi_unit,"(a,f6.4,a)") "'bias_",xi_val,"/xi_distribution.dat' w l,\"
!
!     Calculate umbrella coordinate here (only for single type)
!
      write(15,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= ",trim(subfname), &
            & " for",real(gen_step)*dt_info," ps."
      write(*,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= ",trim(subfname), &
            & " for",real(gen_step)*dt_info," ps."
!      stop "Guogou"
!
!     In case that an error occured during dynamics, restart the trajectory
!     with the geometry stored before
!
      q_i_save=q_i
      112 continue
!
!     If too many errors occured in this phase, reset the whole structure generation!
!
      if (err_count .gt. (err_max/reset_prob)*gen_reset) then
         write(*,*) "OOOPS! The calculation failed too many times already in this early stage!"
         write(*,*) "We will completely reset the whole start structure generation..."
         gen_reset=gen_reset+1
         if (err_count .ge. err_max) then
            write(*,*) "maximal number of errors reached!!"
            call fatal
         end if
         goto 111
      end if
!
!     Set the index of the current umbrella window for determination of the local
!     force constant (if needed)
!
      um_window_act=n_all+i-(n_over+1) 
!
!     Reinitialize the dynamics (momenta etc.)
!     (first: dynamic allocation for Andersen thermostat or initialization of GLE)
!    
!      if (thermostat .eq. 0) then
!         if (andersen_step .eq. 0) then
!            andersen_step=30!int(dsqrt(dble(gen_step)))
!         end if
!      else if (thermostat .eq. 1) then
!         stop "no GLE implemented!"
!      end if
  !    call mdinit_bias(xi_val,dxi_act,derivs,1,2)

      call mdinit(derivs,xi_val,dxi_act,2,rank)
      do istep = 1, gen_step
         call verlet(istep,dt,derivs,energy_act,0d0,0d0,xi_val,xi_real,dxi_act,i,0,.false.,rank)
    !     call verlet_bias (istep,dt,xi_val,xi_real,dxi_act,energy_act,derivs,i,0)
!
!          call verlet_bias (istep,dt,xi_val,xi_real,dxi_act,energy_act,derivs,i,0)
!     check the trajectory, if failed, go to beginning of trajectory
!
         if (act_check .and. istep .gt. 10) then
            call rpmd_check(istep,gen_step,1,0,0,energy_act,xi_val,xi_real,&
                        & energy_ts,err_act,struc_reset,err_count,traj_error)

            if (traj_error .eq. 1) then
               q_i=q_i_save
               goto 112
            end if
         end if
      end do
!
!     Save last structure of the run in global array
!
      xi_wins(n_all+i-(n_over+1))=xi_val
      start_xis(n_all+i-(n_over+1))=xi_real
      struc_equi(n_all+i-(n_over+1),1,:)=q_i(1,:,1)
      struc_equi(n_all+i-(n_over+1),2,:)=q_i(2,:,1)
      struc_equi(n_all+i-(n_over+1),3,:)=q_i(3,:,1)
      equi_energy(n_all+i-(n_over+1))=energy_act
   end do
!
!     Reset actual structure to the sampled structure at Xi=1.00
!

   do i=1,natoms
      q_i(1,i,1)=struc_equi(n_all-n_over,1,i)
      q_i(2,i,1)=struc_equi(n_all-n_over,2,i)
      q_i(3,i,1)=struc_equi(n_all-n_over,3,i)
   end do

!
!    Now simulate the windows from xi=1.0 to xi=0.0 or lower
!
   do i=1,n_samplings
      xi_val=1-i*umbr_dist
      if (xi_val .lt. 0.0d0) then
         write(subfname,"(f6.4)") abs(xi_val)
      else 
         write(subfname,"(f6.4)") xi_val
      end if
!
!     write plot line for gnuplot file with Xi distributions during sampling
      if (xi_val .lt. 0.d0) then
         if (i.eq. n_samplings) then
            write(gnu_xi_unit,"(a,a,a)") "'bias_-",trim(subfname),"/xi_distribution.dat' w l"
         else 
            write(gnu_xi_unit,"(a,a,a)") "'bias_-",trim(subfname),"/xi_distribution.dat' w l,\"
         end if
      else 
         if (i.eq. n_samplings) then
            write(gnu_xi_unit,"(a,a,a)") "'bias_",trim(subfname),"/xi_distribution.dat' w l"
         else
            write(gnu_xi_unit,"(a,a,a)") "'bias_",trim(subfname),"/xi_distribution.dat' w l,\"
         end if
      end if

      if (xi_val .lt. 0.0d0) then
         write(15,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= -",trim(subfname), &
             & " for",real(gen_step)*dt_info," ps."
         write(*,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= -",trim(subfname), &
             & " for",real(gen_step)*dt_info," ps."
      else 
         write(15,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= ",trim(subfname), &
             & " for",real(gen_step)*dt_info," ps."
         write(*,'(a,a,a,f11.4,a)') " Begin structure generation at Xi= ",trim(subfname), &
             & " for",real(gen_step)*dt_info," ps."
      end if
!
!     In case that an error occured during dynamics, restart the trajectory
!     with the geometry stored before
! 
      q_i_save=0.d0
      q_i_save(:,:,1)=q_i(:,:,1)
      113 continue
!
!     If too many errors occured in this phase, reset the whole structure generation!
!
      if (err_count .gt. (err_max/reset_prob)*gen_reset) then
         write(*,*) "OOOPS! The calculation failed too many times already in this early stage!"
         write(*,*) "We will completely reset the whole start structure generation..."
         gen_reset=gen_reset+1
         goto 111
      end if
!
!     Set the index of the current umbrella window for determination of the local
!     force constant (if needed)
!
      um_window_act=n_samplings-i+1

!
!     Reinitialize the dynamics (momenta etc.)
!
 !     call mdinit_bias(xi_val,dxi_act,derivs,1,2)
      call mdinit(derivs,xi_val,dxi_act,2,rank)
      do istep = 1, gen_step
         if (istep .eq. 1) then
!
!     avoid definition bugs...
!
            write(a80,'(a,3e14.7)') "theq",q_i(:,1,1)
         end if
         call verlet(istep,dt,derivs,energy_act,0d0,0d0,xi_val,xi_real,dxi_act,i,0,.false.,rank) 
!         call verlet_bias (istep,dt,xi_val,xi_real,dxi_act,energy_act,derivs,i,0)
         if (istep .eq. 1) then
!
!     avoid definition bugs...
!
            write(a80,'(a,e14.7)') "energy",energy_act
         end if

!
!     check the trajectory, if failed, go to beginning of trajectory
!
         if (act_check) then
            call rpmd_check(istep,gen_step,1,0,0,energy_act,xi_val,xi_real,energy_ts,&
                     & err_act,struc_reset,err_count,traj_error)
            if (traj_error .eq. 1) then
               q_i=0.d0
               q_i(:,:,1)=q_i_save(:,:,1)
               goto 113
            end if
         end if
      end do
!
!     Save last structure of the run in global array
!
      xi_wins(n_samplings-i+1)=xi_val
      start_xis(n_samplings-i+1)=xi_real   
   
      struc_equi(n_samplings-i+1,1,:)=q_i(1,:,1)
      struc_equi(n_samplings-i+1,2,:)=q_i(2,:,1)
      struc_equi(n_samplings-i+1,3,:)=q_i(3,:,1)

      equi_energy(n_samplings-i+1)=energy_act
   end do

!
!     close plot file for Xi distributions
!
   write(gnu_xi_unit,*) "pause -1"
   close(gnu_xi_unit)
 
!
!     Write equilibrated structures and Xi positions to files
!     convert them back into angstrom for better debug abilities
!     Calculate also center of masses for structures and shift 
!     them to set the COM at the origin
!
   open(unit=44,file="equilibrated_ens.dat",status="unknown")
   open(unit=55,file="xi_pos.dat",status="unknown")
   open(unit=56,file="equilibrated_struc.xyz",status="unknown")
   do i=1,n_all-1
      write(56,*) natoms
      write(44,*) equi_energy(i)
      write(55,*) xi_wins(i)
      write(xi_real_unit,*) start_xis(i)
      write(56,*) "ideal:",xi_wins(i),"real:",start_xis(i)
      if (umbr_type .ne. "ATOM_SHIFT") then
!
!     calculate COM (not used for ATOM SHIFT, since there absolute coordinate 
!        are important)
!
         centom=0.d0
         do j=1,natoms
            do k=1,3
               centom(k)=centom(k)+struc_equi(i,k,j)*mass(j)
            end do
         end do     
         centom=centom/sum(mass(1:natoms))  
!
!     shift actual structure by COM
!     
         do j=1,natoms
            struc_equi(i,:,j)=struc_equi(i,:,j)-centom
         end do
      end if

      do j=1,natoms
         write(56,*) name(j),struc_equi(i,:,j)*bohr
      end do
   end do
   close(56)
   close(55)
   close(44)
   close(xi_real_unit)
!
!     deallocate array with equilibrated structures
!
   deallocate(struc_equi,xi_wins)

   call system("touch start_finished")
   write(15,*) "----------------------------------------------"
   write(15,*) "Starting structure generation finished!"
   write(*,*) "----------------------------------------------"
   write(*,*) "Starting structure generation finished!"
else
   if (rank .eq. 0) then
      write(15,*)
      write(15,*) "Equilibration was done in a previous run!"
      write(15,*) "Delete the file 'start_finished' first if you want to"
      write(15,*) "do it once again!"
      write(*,*) 
      write(*,*) "Equilibration was done in a previous run!"
      write(*,*) "Delete the file 'start_finished' first if you want to"
      write(*,*) "do it once again!"
   end if
end if
!
!     If the option GEN_TEST was activated, only start structures will be optimized,
!     some structures and energies will be printed out
!
if (gen_test) then
   write(*,*) "We will stop the calculation at this point because gen_test has been activated!"
   write(*,*) "structures: gen_test_struc.xyz, energies,s-vals,z-vals: gen_test_ens.dat"
   close(295)
   close(296)
   stop
end if
!
!     close debug unit if opened
!
if (do_debug) then
   close(debug_unit)
end if
!
! --------------------------------------------------------!
!     BEGIN THE UMBRELLA SAMPLINGS
!     USE THE START STUCTURES AND PERFORM THE MAIN PART
! --------------------------------------------------------!
! 
!     Perform umbrella samplings for all structures
!     Read the former results form 'equilibrated_struc.xyz' and 
!     write variable values as well as coordinates etc. into 
!     single folders! 
!     --> Parallelized with MPI
!
!     (re-)allocate array with equilibrated structures
!
call mpi_barrier(mpi_comm_world,ierr)

!
!    Measure the needed time for umbrella samplings
!
if (rank .eq. 0) then
   call cpu_time(time(3))
end if

dont_umbr=.true.
!
!     set the number of beads to the stored value
!

nbeads=nbeads_store
inquire(file="sampling_finished", exist=dont_umbr)
!
!     reallocate the q_i array for the zeroth process, else 
!     strange segmentation faults appear in the recrossing section...
!     --> update: now for all processes, since recrossing will be 
!     calculated parallelized
if (allocated(p_i)) deallocate(p_i)
allocate(p_i(3,natoms,nbeads))
!
!     Initialize the random number generator!
! 
if (rank .eq. 1) then
   call random_init_local(rank)
end if

if (.not. dont_umbr) then
!
!     Generate the two folders for run statistics and xi distributions if not 
!     already existing
!  
   if (rank .eq. 0) then
      inquire(file="statistics", exist=exist) 
   !   if (exist) call system("rm -r statistics")
      if (.not. exist) call system("mkdir statistics")
      inquire(file="xi_distributions", exist=exist)
   !   if (exist) call system("rm -r xi_distributions")
      if (.not. exist)  call system("mkdir xi_distributions")
   end if
 
   allocate(struc_equi(n_all,3,natoms))
   allocate(xi_wins(n_all))
   if (rank .eq. 0) then
      write(15,*)
      write(15,*) "-------------------PART   2-------------------"
      write(15,*) "Perform parallel umbrella samplings."
      write(15,*) "The first processor will be the master, all others "
      write(15,*) "are workers"
      write(15,*) "----------------------------------------------"
      write(15,*) 
      write(15,*) "Due to bugs with MPI, detailed informations about"
      write(15,*) "detailed informations about the current status of"
      write(15,*) "the current samplings are only written to the terminal."
      write(*,*) 
      write(*,*) "-------------------PART   2-------------------"
      write(*,*) "Perform parallel umbrella samplings."
      write(*,*) "The first processor will be the master, all others " 
      write(*,*) "are workers"
      write(*,*) "----------------------------------------------"
   end if
   call mpi_barrier(mpi_comm_world,ierr) 
!
!     Read from files:
!
   open(unit=55,file="xi_pos.dat",status="unknown")
   open(unit=56,file="equilibrated_struc.xyz",status="unknown")
   do i=1,n_all-1
      read(56,*) natoms
      read(56,*) 
      read(55,*) xi_wins(i)
      do j=1,natoms
         read(56,*) names,struc_equi(i,:,j)
         struc_equi(i,:,j)=struc_equi(i,:,j)/bohr
      end do
   end do
   close(56)
   close(55)
 
!
!     Loop over all windows and over all single samplings per 
!     window:
!     Do umbrella equilibration first, then umbrella sampling
!
!     define default tag value
   tag_mpi=0
!     define default count value
   count=1
!     define the number of worksteps 
   maxwork=n_all-1
!
!     calculate width of a single bin
!
   bin_size=(xi_max-xi_min)/(nbins-1)
!
!     number of umbrella windows to be sampled
!
   num_umbrella=n_all-1+psize-1
!
!     allocate local array with number of hits for each bin (for each window)
!

   if (allocated(bin_entries) .eqv. .false.) allocate(bin_entries(nbins))
!
!     actual piece of work for slave
!
!     The master process (rank=0) it sends the actual sampling tasks
!     to the worker that will do the samplings
!
   if (rank .eq. 0) then
      dest=1

      do i=1,num_umbrella
         call mpi_recv(message, count, MPI_DOUBLE_PRECISION, MPI_ANY_SOURCE,tag_mpi, &
            & MPI_COMM_WORLD,status,ierr)
         dest=message  ! chose the next adress: adress sent from actual slave
         if (i .le. maxwork) then
            call mpi_send(i, count, MPI_DOUBLE_PRECISION, dest,tag_mpi,MPI_COMM_WORLD,ierr)
         else
            call mpi_send(-1, count, MPI_DOUBLE_PRECISION, dest,tag_mpi,MPI_COMM_WORLD,ierr)
         end if
      end do
!
!     worker (all other processes): sends to the master and starts if it recieves 
!     an answer from it
!     Then start the single samplings and go back if finished
!
   else
      source=0
      message=rank
      do
         call mpi_send(message, count, MPI_DOUBLE_PRECISION, source,tag_mpi,MPI_COMM_WORLD,ierr)
         call mpi_recv(numwork, count, MPI_DOUBLE_PRECISION, 0,tag_mpi,MPI_COMM_WORLD,status,ierr)
!
!     If no more samplings are to do, exit with the current worker
!
         if (numwork .eq. -1) then

            exit
         end if
      
!
!     determine current start structure
!     give all beads the same structure stored before from generation!
!
         k=numwork  ! current run index
         do j=1,nbeads
            q_i(1,:,j)=struc_equi(k,1,:)
            q_i(2,:,j)=struc_equi(k,2,:)
            q_i(3,:,j)=struc_equi(k,3,:)
         end do
         xi_val=xi_wins(k)
         if (xi_val .lt. 0.0d0) then
            write(subfname,"(f6.4)") abs(xi_val)
         else
            write(subfname,"(f6.4)") xi_val
         end if
         iout=68
         if (umbr_type .eq. "SINGLE") then
            call umbr_coord(xi_val,int_curr)
         end if
!
!     Set the index of the current umbrella window for determination of the local
!     force constant (if needed)
!
         um_window_act=k

!
!     set averages and variances to zero
!
         average(k)=0.d0
         variance(k)=0.d0
!
!     Check if statistics file is already present for current bias position!
!     If existent, open file and check if enough lines are in it 
!
         run_finished=.false.
         if (xi_val .lt. 0.0d0) then
            inquire(file="statistics/bias_-"//subfname,exist=exist)
            if (exist) run_finished=.true.
         else
            inquire(file="statistics/bias_"//subfname,exist=exist)
            if (exist) run_finished=.true.
         end if
         if (run_finished) then
            if (xi_val .lt. 0.0d0) then
               open(unit=50,file="statistics/bias_-"//subfname,status="unknown")
            else 
               open(unit=50,file="statistics/bias_"//subfname,status="unknown")
            end if
            num_lines=0
            do
               read(50,'(a)',iostat=lastline) a80
               if (lastline .ne. 0) exit
               num_lines=num_lines+1
            end do
!
!     If 5 header lines and one additional line for each sampling trajectory is 
!     present, assume, that the calculation was done
!
            if (num_lines .eq. umbr_traj +5) then
               if (xi_val .lt. 0.0d0) then
                  write(*,'(a,a,a)') "Umbrella samplings were already done for Xi= -",&
                      & trim(subfname),"! Go to next calculation..."
               else
                  write(*,'(a,a,a)') "Umbrella samplings were already done for Xi= ",&
                      & trim(subfname),"! Go to next calculation..."  
               end if 
            else 
               run_finished=.false.
            end if
            close(50)
         end if
!
!     If the run was not already finished, do it again...
!
         if (.not. run_finished) then
!
!     Open file with statistics (average and variances) for all trajectories
!     if this run was not calculated before 
!
            if (xi_val .lt. 0.0d0) then
               open(unit=50,file="statistics/bias_-"//subfname,status="unknown")
            else 
               open(unit=50,file="statistics/bias_"//subfname,status="unknown")
            end if

            write(50,*) "# The distribution characteristics for the actual umbrella window:"
            write(50,*) "#             Traj-No.        average           variance"

          
            do j=1,umbr_traj
!
!     reset the local xi distribution in the bins
!        
               bin_entries=0.d0
!
!     first umbrella equilibration
! 
               if (j.lt.10) then
                  write(subsubfname,"(i1)") j
               else if (j.lt.100) then
                  write(subsubfname,"(i2)") j
               else 
                  write(subsubfname,"(i3)") j
               end if
               writestat=.false.
               if (xi_val .lt. 0.0d0) then
                  write(*,'(a,a,a,i3,a,f11.5,a)') "Begin equilibration at Xi= -",&
                      & trim(subfname)," in round ",j," for ",real(equi_step)*dt_info," ps."
               else 
                  write(*,'(a,a,a,i3,a,f11.5,a)') "Begin equilibration at Xi= ",&
                      & trim(subfname)," in round ",j," for ",real(equi_step)*dt_info," ps."
               end if 
!
!     In case that an error occured during dynamics, restart the trajectory
!     at this point (also for umbrella samplings!)
! 
               114 continue
!
!     reset local average and variance values
!
               average_act=0.d0
               variance_act=0.d0
!
!     Reinitialize the dynamics (momenta etc.)
!
       !        call mdinit_bias(xi_val,dxi_act,derivs,1,2) 
               call mdinit(derivs,xi_val,dxi_act,2,rank)
!
!     Run the current umbrella trajectory for equilibration
!     
!     Reset the thermostat
!
             !  andersen_step=0
         !      if (thermostat .eq. 1) then
         !         if (andersen_step .eq. 0) then
         !      !      andersen_step=80!int(dsqrt(dble(equi_step)))
         !         end if
         !      else if (thermostat .eq. 1) then
         !         stop "No GLE implemented!"
         !      end if
               do istep = 1, equi_step
                  call verlet(istep,dt,derivs,energy_act,0d0,0d0,xi_val,xi_real,dxi_act,j,0,.false.,rank)
               !   call verlet_bias (istep,dt,xi_val,xi_real,dxi_act,energy_act,derivs,j,0)
!
!     check the trajectory, if failed, go to beginning of trajectory
!
                  if (act_check) then
                     call rpmd_check(istep,equi_step,2,k,n_all-1+psize-1,energy_act,xi_val,xi_real,&
                              & energy_ts,err_act,struc_reset,err_count,traj_error)
                     if (traj_error .eq. 1) then
                        goto 114
                     end if
                  end if
               
               end do

!
!     then the actual sampling: Save trajectories, bias potentials 
!     and other MD statistics (temperature etc.) in the work folders
!
               writestat=.true.
               open(unit=66,file="bias_pot.dat",status="unknown")
               open(unit=28,file="trajectory.xyz",status="unknown")
               if (xi_val .lt. 0.0d0) then
                  write(*,'(a,a,a,i3,a,f11.5,a)') "Begin sampling at Xi= -",&
                     & trim(subfname)," in round ",j," for ",real(umbr_step)*dt_info," ps."
               else 
                  write(*,'(a,a,a,i3,a,f11.5,a)') "Begin sampling at Xi= ",&
                     & trim(subfname)," in round ",j," for ",real(umbr_step)*dt_info," ps."
               end if
!
!     if desired, open the print folder in the main calculation folder
!     temperature
!
               if ((j .eq. 1) .and. (xi_val .eq. print_poly)) then
                  iwrite = nint(dtdump/(dt))
                  write(*,*) "This trajectory will be printed out to file calc_rate_traj.xyz ."
                  open(unit=117,file="calc_rate_traj.xyz",status="unknown")
               end if
            
          !     andersen_step=0
          !     if (thermostat .eq. 0) then
          !        if (andersen_step .eq. 0) then
          !           andersen_step=80!floor(dsqrt(dble(umbr_step)))
          !        end if  
          !     else if (thermostat .eq. 1) then
          !        stop "No GLE implemented!"
          !     end if
!
!     calculate unbiased gradient for first sampling step
!
               do i=1,nbeads
                  q_1b=q_i(:,:,i)
                  call gradient (q_1b,epot,derivs_1d,i,rank)
                  derivs(:,:,i)=derivs_1d
               end do
               do istep = 1, umbr_step

                  call verlet(istep,dt,derivs,energy_act,0d0,0d0,xi_val,xi_real,dxi_act,k,0,.false.,rank)
            !      call verlet_bias (istep,dt,xi_val,xi_real,dxi_act,energy_act,derivs,k,0)
!
!     check the trajectory, if failed, go to beginning of the equilibration trajectory
!     then also reset actual values of average and variance
!
                  if (act_check) then
                     call rpmd_check(istep,equi_step,3,k,n_all-1+psize-1,energy_act,xi_val,xi_real,&
                           &energy_ts,err_act,struc_reset,err_count,traj_error)
                     if (traj_error .eq. 1) then
                        goto 114
                     end if
                  end if
                  average_act=average_act+xi_real
                  variance_act=variance_act+xi_real*xi_real

!
!     If the additional option print_polymer is activated: print 
!     out the first umbrella sampling trajectory for a given Xi value 
!     along the reaction path
!              
                  if ((j .eq. 1) .and. (abs(xi_val-print_poly) .lt. 0.00001)) then! .and. &
                             !    & (mod(istep,iwrite) .eq. 0)) then
                     if (mod(istep,iwrite) .eq. 0) then
                        write(117,*) natoms*nbeads
                        write(117,'(a,f11.6,a,i3,a)') "Umbr. sampling at Xi= ",xi_val," for ", &
                               & nbeads," beads."
                        do p=1,nbeads
                           do l=1,natoms
                           write(117,*) name(l),q_i(:,l,p)*bohr
                           end do
                        end do
                     end if
             !     end do
                  end if
               end do

               if ((j .eq. 1) .and. (xi_val .eq. print_poly)) then
                  close(117)
               end if

               close(66)
               close(28)
!
!     calculate average and variance for this trajectory
!
               average_act=average_act/umbr_step
               variance_act=variance_act/umbr_step
               variance_act=variance_act-average_act*average_act
!
!     Check if actual variance is too high, might be a sign of a destroyed trajectory!
!     then restart the trajectory
!
               if (variance_act .gt. 1E-3) then
                  write(*,*) "ERROR! The variance for this trajectory is too high!"
                  write(*,*) " (actual:",variance_act," troughput: 1.0000E-04)"
                  write(*,*) "Restart the trajectory..."
                  err_count=err_count+1
                  goto 114
               end if
!
!     write current statistics to file 
!
               write(50,*) j,average_act,variance_act
!
!     update global average and variance values for this umbrella window
!
               average(k)=average(k)+average_act
               variance(k)=variance(k)+variance_act
            end do
         
!
!    Calculate final averages and variance for umbrella integration
!    divide through total number umbrella trajs per window
!         
            average(k)=average(k)/umbr_traj
            variance(k)=variance(k)/umbr_traj
!
!    Write averaged average and variance for all trajectories
!
            write(50,*) 
            write(50,*) "# Averaged values:"
            write(50,*) xi_val,average(k),variance(k) 
            close(50)
       !  stop "Hphuio"
!
!     write distribution of actual measured xi values to file!
!     --> does not work in the moment!

!         if (xi_val .lt. 0.0d0) then
!            open(unit=50,file="xi_distributions/bias_-"//subfname,status="unknown") 
!         else 
!            open(unit=50,file="xi_distributions/bias_"//subfname,status="unknown")
!         end if
!         do j=1,nbins
!            write(50,*) xi_min+j*bin_size,bin_entries(j)
!         end do
!         close(50)
       !  call chdir("..")
          end if
      end do
   end if
!
!    Indicate finished umbrella sampling for later runs
!
   deallocate(struc_equi)
   call mpi_barrier(mpi_comm_world,ierr)
   call system("touch sampling_finished")
else
!
!     Skip the section if sampling was made before
!
   if (rank .eq. 0) then
      write(15,*)
      write(15,*) "Umbrella Samplings were done in a previous run!"
      write(15,*) "Delete the file 'sampling_finished' first if you want to"
      write(15,*) "do it once again!"
      write(*,*)
      write(*,*) "Umbrella Samplings were done in a previous run!"
      write(*,*) "Delete the file 'sampling_finished' first if you want to"
      write(*,*) "do it once again!"
   end if
end if
!stop "HGouguogoug"
call mpi_barrier(mpi_comm_world,ierr)

!
! --------------------------------------------------------!
!     EVALUATE THE UMBRELLA SAMPLINGS
!     READ IN THE RESULTS AND CALCULATE XI DISTRIBUTIONS
! --------------------------------------------------------!
! 
!     Go again into the written result folders and read in 
!     the Xi distributions for all of them
!     Then assign the distributions to the single windows 
!     from which the free energy surface will be computed 
!     in the next step
!     --> Now again serial execution
!
!
!    Measure the needed time for results evaluation of umbrella samplings
!
if (rank .eq. 0) then
   call cpu_time(time(4))
end if

if (rank .eq. 0) then
   write(15,*)
   write(15,*) "-------------------PART   3-------------------"
   write(15,*) "Evaluate the results of the umbrella samplings:"
   write(15,*) "Calulate the free energy surface from the xi-distributions."
   write(*,*)
   write(*,*) "-------------------PART   3-------------------"
   write(*,*) "Evaluate the results of the umbrella samplings:"
   write(*,*) "Calulate the free energy surface from the xi-distributions."

   if (allocated(xi_wins) .eqv. .false.) allocate(xi_wins(n_all))
   open(unit=55,file="xi_pos.dat",status="unknown")
   do i=1,n_all-1
      read(55,*) xi_wins(i)
   end do
   close(55)
!
!     perform the lengthy read in tasks only if the WHAM method is 
!     used!
!
   if ((pmf_method .eq. "WHAM") .or. (pmf_method .eq. "ALL")) then
!
!     allocate global array with number of hits for each bin
!     for each sampling xi value
!
      if (allocated(all_bin_entries) .eqv. .false.) allocate(all_bin_entries(n_all,nbins))
      all_bin_entries=0.d0
!
!     calculate width of a single bin
!
      bin_size=(xi_max-xi_min)/(nbins-1)
!
!     Open all files with xi-distributions in their folder and read them
!
      do i=1,n_all-1
         xi_val=xi_wins(i)
         if (xi_val .lt. 0.0d0) then
            write(subfname,"(f6.4)") abs(xi_val)
         else
            write(subfname,"(f6.4)") xi_val
         end if
!
!     Now evaluate the xi-values: Decide, in which PMF bin they are
!
         if (xi_val .lt. 0.0d0) then
            open(unit=50,file="xi_distributions/bias_-"//subfname,status="old") 
         else 
            open(unit=50,file="xi_distributions/bias_"//subfname,status="old")
         end if
         do j=1,nbins
            read(50,*) rdummy,all_bin_entries(i,j)
         end do
         close(50)
      end do
!
!     Finally, write all bin distributions to file and create a suitable
!     gnuplot file
!
      open(unit=89,file="all_histograms.dat",status="unknown")
      do i=1,nbins
         write(89,*) xi_min+i*bin_size,all_bin_entries(:,i)
      end do
      close(89)
      open(unit=90,file="sum_histogram.dat",status="unknown")
      do i=1,nbins
         write(90,*) xi_min+i*bin_size,sum(all_bin_entries(:,i))
      end do
      close(90)
!
!     gnuplot file for single histograms
!    
      open(unit=91,file="plot_histogram.gnu",status="unknown")
      write(91,*) "set xlabel '# bin'"
      write(91,*) "set ylabel 'No. of hits'"
      write(91,*) "unset key"
      write(91,*) "set xrange [",xi_min,":",xi_max,"]"
      write(91,'(a)',advance="no") "plot 'all_histograms.dat' u 1:2 w l,"
      do i=1,n_all-3
         write(91,'(a,i3,a)',advance="no") "'' u 1:",i+1," w l,"
      end do
      write(91,'(a,i3,a)') "'' u 1:",n_all+1,"w l"
      write(91,*) "pause -1"
      close(91)
!
!     gnuplot file for summed histogram of all samplings
!
      open(unit=92,file="plot_sum.gnu",status="unknown")
      write(92,*) "set xlabel '# bin'"
      write(92,*) "set ylabel 'No. of hits'"
      write(92,*) "unset key"
      write(92,*) "set xrange [",xi_min,":",xi_max,"]"
      write(92,*) "plot 'sum_histogram.dat' u 1:2 w l"
      write(92,*) "pause -1" 
      close(92)
!
!     for umbrella integration: read in the averages and variances of all
!     windows (they cant be written to one file due to MPI variables..)
!
   end if
   if ((pmf_method .eq. "INTEGRATION") .or. (pmf_method .eq. "ALL")) then
!
!     Go through all main folders (bias_...)
!
      do i=1,n_all-1
         xi_val=xi_wins(i)
         if (xi_val .lt. 0.0d0) then
            write(subfname,"(f6.4)") abs(xi_val)
         else
            write(subfname,"(f6.4)") xi_val
         end if
         if (xi_val .lt. 0.0d0) then
            open(unit=50,file="statistics/bias_-"//subfname,status="old") 
         else 
            open(unit=50,file="statistics/bias_"//subfname,status="old")
         end if
         read(50,*) names
         read(50,*) names
         do k=1,umbr_traj
            read(50,*) names
         end do
         read(50,*) names
         read(50,*) xi_val,average(i),variance(i)
         close(50)
      end do
!
!     write global file with averages and variances for umbr. int.
!
      open(unit=93,file="umbr_int.dat",status="unknown")
      write(93,*) "# xi_position      average(xi)       variance(xi)"
      do i=1,n_all
         write(93,*) xi_wins(i),average(i),variance(i)
      end do
      close(93)
   end if
end if
call mpi_barrier(mpi_comm_world,ierr)
! --------------------------------------------------------!
!     CALCULATE THE FREE ENERGY SURFACE
!     USE ALL SAMPLING DISTRIBUTIONS FOR WHAM EQUATION
! --------------------------------------------------------!
! 
!     Two possibilities:
!     1. Use umbrella integration from KÃ¤stner and Thiel, 
!     only averages and variances for all windows are used
!     2. Call the external WHAM-routine taken from literature 
!     and calculate the surface using the distributions 
!     stored into the bin_entries array
! 
!     If both methods shall be used, jump into both else statements!
!
!
!
!     Measure the needed time for the free energy calculation
!
if (rank .eq. 0) then
   call cpu_time(time(5))
end if

if (rank .eq. 0) then
!
!     UMBRELLA-INTEGRATION:
!     go to the implementation in this mainprogram
!
   if (pmf_method .eq. "INTEGRATION" .or. pmf_method .eq. "ALL") then
      write(15,*) "The Umbrella Integration by KÃ¤stner and Thiel is used."
      write(15,*) "----------------------------------------------"
      write(*,*) "The Umbrella Integration by KÃ¤stner and Thiel is used."
      write(*,*) "----------------------------------------------"
!
!     two loops: for each bin, calculate values of normal distributions 
!     centered at  all windows
!
!
!     calculate width of a single bin
!
      bin_size=(xi_max-xi_min)/(nbins-1)

      if (allocated(p_ib) .eqv. .false.) allocate(p_ib(n_all)) 
      if (allocated(dA_iu) .eqv. .false.) allocate(dA_iu(n_all))
      if (allocated(dA) .eqv. .false.) allocate(dA(nbins))
      dA=0.d0
      do j=1,nbins
         denom=0.d0
         xi_act=xi_min+bin_size*((j-1))
         do i=1,n_all-1
            p_ib(i)=1.d0/(sqrt(2.d0*pi*variance(i)))*exp(-0.5d0*((xi_act- &
                  & average(i)))**2/variance(i))
            dA_iu(i)=(1.d0/beta)*(xi_act-average(i))/(variance(i))- &
                  & k_force(i)*(xi_act-xi_wins(i))
!            stop
         end do 
!     Sum up the distributions for the actual bin
         do k=1,n_all-1 
            denom=denom+(umbr_traj*umbr_step)*p_ib(k)
         end do
         do k=1,n_all-1
            dA(j)=dA(j)+(umbr_traj*umbr_step)*p_ib(k)*dA_iu(k)
         end do
         dA(j)=dA(j)/denom
      end do
!
!     at the end: integrate numerically over dA array
!
      A_act=0.d0
      if (allocated(bin_coord) .eqv. .false.) allocate(bin_coord(nbins))
      if (allocated(pmf) .eqv. .false.) allocate(pmf(nbins))
      pmf=0.d0      
      dx=bin_size
      do i=1,nbins-1
         bin_coord(i)=0.5d0*(xi_min+((i-1))*dx+xi_min+((i))*dx)
         A_act=A_act+0.5d0*dx*(dA(i)+dA(i+1))
         pmf(i)=A_act
      end do
!
!     For nicer view: set the minimal value of the PMF curve to zero
!
      pmf=pmf-minval(pmf)
!
!     Write the PMF profile to file (converted to kJ/mol)
!
      open(unit=94,file="pmf_integration.dat",status="unknown")
      write(94,*) "# xi-value     PMF(kJ/mol)"
      do i=1,nbins-1
         write(94,*) bin_coord(i),pmf(i)*2625.50d0
      end do
      close(94)
      write(15,*) "Umbrella Integration finished! PMF stored to pmf_integration.dat."
      write(*,*) "Umbrella Integration finished! PMF stored to pmf_integration.dat."
!
!     WHAM-EQUATIONS:
!     call the subroutine taken from literature!
!  
   end if
   if ((pmf_method .eq. "WHAM") .or. (pmf_method .eq. "ALL")) then
      write(15,*) "The Weighted Histogram Analysis Method (WHAM) is used."
      write(15,*) "----------------------------------------------"
      write(*,*) "The Weighted Histogram Analysis Method (WHAM) is used."
      write(*,*) "----------------------------------------------"
      allocate(pmf_wham(nbins))  ! if only WHAM is used, take its free energy
      call wham(nbins,n_all,xi_min,xi_max,bin_size,xi_wins,all_bin_entries,pmf_wham)
      write(15,*) "WHAM iterations finished! PMF stored to pmf_wham.dat."
      write(*,*) "WHAM iterations finished! PMF stored to pmf_wham.dat."
!
!     if only WHAM is used, overwrite the free energy surface..
!     (usually the umbrella integration surface seems to be better..)
!
      if (pmf_method .eq. "WHAM") then
         pmf=pmf_wham
      end if
   end if
end if

call mpi_barrier(mpi_comm_world,ierr)
if (int_coord_plot) close(191)
! --------------------------------------------------------!
!     CALCULATE THE RECROSSING FACTOR
!     SAMPLE PARENT TRAJECTORYi AND CHILDREN 
! --------------------------------------------------------!

!
!     first, determine the maximum and minimum of the free energy and the 
!     respective xi coordinate
!     The minimum needs to be at approx xi=0 in order to fulfill the 
!     prerequisites of the QTST k(T) formula!
!     For unimolecular reactions, it is more useful to determine the minimum 
!     position freely!
!
if ((umbr_type .eq. "ATOM_SHIFT") .or. (umbr_type .eq. "CYCLOREVER") .or. &
          & (umbr_type .eq. "REARRANGE") .or. (umbr_type .eq. "DECOM_1BOND") .or. &
          & (umbr_type .eq. "ELIMINATION")) then
   pmf_minloc="PMF_MIN"
   if (add_force) then
     pmf_minloc="ZERO"
   end if
end if
!
!    Measure the needed time for the recrossing calculation
!
if (rank .eq. 0) then
   call cpu_time(time(6))
end if

if (rank .eq. 0) then
!   MOD 11.02.2023: Replaced complicated maxloc formula by simple one..
   maxlocate=maxloc(pmf(:),dim=1)
!   maxlocate=maxloc(pmf(-int(xi_min/((xi_max-xi_min)/(nbins)))+1:nbins-1),dim=1)
!
!     If the position for the recrossing has been chosen manually, 
!         set its value here
!
   pmf_maxlocate=maxlocate
   xi_pmf_max=bin_coord(maxlocate)
   if (xi_pos_manual .gt. -1D50) then
      allocate(bin_tmp(nbins))
      do i=1,nbins
         bin_tmp(i)=abs(bin_coord(i)-xi_pos_manual)
      end do
      xi_barrier=xi_pos_manual
      maxlocate=minloc(bin_tmp(:),dim=1)
      deallocate(bin_tmp)
   else
      xi_barrier=bin_coord(maxlocate)
   end if
!
!     Take the reactant asymptotic (xi=zero) as lowest PMF value
!
   if (pmf_minloc .eq. 'ZERO') then
      minlocate=-int(xi_min/((xi_max-xi_min)/(nbins)))+1
!
!     Take the lowest PMF value left the TS as the lowest one 
!
   else
      minlocate=minloc(pmf(1:maxlocate),dim=1)
   end if
!
!     Calculate the Xi value for the lowest bin
!
   xi_minimum=bin_coord(minlocate)
end if

if (skip_recross) then
   if (rank .eq. 0) then
      write(*,*)
      write(*,*) "The recrossing part will be skipped, since no child"
      write(*,*) " trajectories shall be sampled. Kappa set to 1."
      write(*,*)
      write(15,*)
      write(15,*) "The recrossing part will be skipped, since no child"
      write(15,*) " trajectories shall be sampled. Kappa set to 1."
      write(15,*)
   end if
   kappa=1.0
   goto 333
end if
if (rank .eq. 0) then
   write(15,*)
   write(15,*) "-------------------PART   4-------------------"
   write(15,*) "Calculate the recrossing factor."
   write(15,*) "First, sample a parent trajectory, then start "
   write(15,*) "many child trajectories from its configurations."
   write(15,*) "----------------------------------------------"
   write(*,*)
   write(*,*) "-------------------PART   4-------------------"
   write(*,*) "Calculate the recrossing factor."
   write(*,*) "First, sample a parent trajectory, then start "
   write(*,*) "many child trajectories from its configurations."
   write(*,*) "----------------------------------------------"
   if (xi_pos_manual .gt. -1D50) then
      write(15,*) "For this calculation, the position of the recrossing plane "
      write(15,*) " (usually at the PMF maximum) has been altered manually"
      write(15,'(a,f12.6,a)') "  to ",xi_pos_manual,"!"
      write(*,*) "For this calculation, the position of the recrossing plane "
      write(*,*) " (usually at the PMF maximum) has been altered manually"
      write(*,'(a,f12.6,a)') "  to ",xi_pos_manual,"!"
   end if


end if

!
!    TEST 10.07.2019
!    Read PMF from file 
!
!open(unit=18,file="pmf_test.dat",status="old")
!do i=1,nbins
!   read(18,*) bin_coord(i),pmf(i)
!end do
!close(18)
!    convert to Hartree
!pmf=pmf/627.509
!
!!

!
!     Read in all equilibrated structures in order to find that next to the TS
!
!     allocate array with starting structures
!
if (allocated(xi_wins) .eqv. .false.) allocate(xi_wins(n_all))
if (allocated(struc_equi) .eqv. .false.) allocate(struc_equi(n_all,3,natoms))
!
!     open written file with starting structure
!
open(unit=55,file="xi_pos.dat",status="unknown")
open(unit=56,file="equilibrated_struc.xyz",status="unknown")
do i=1,n_all-1
   read(56,*) natoms
   read(56,*)
   read(55,*) xi_wins(i)
   do j=1,natoms
      read(56,*) names,struc_equi(i,:,j)
   end do
end do
close(56)
close(55)
!
!     Choose the starting structure for the recrossing parent trajectory:
!      the equilibrated structure with its xi-value nearest to the 
!      calculated xi max value (or the manually chosen value)
!
allocate(xi_tmp(n_all-1))
do i=1,n_all-1
   xi_tmp(i)=abs(xi_wins(i)-xi_barrier)
end do

ts_locate=minloc(xi_tmp(:),dim=1)

do j=1,nbeads
   do i=1,natoms
      q_i(1,i,j)=struc_equi(ts_locate,1,i)/bohr
      q_i(2,i,j)=struc_equi(ts_locate,2,i)/bohr
      q_i(3,i,j)=struc_equi(ts_locate,3,i)/bohr
   end do
end do

!
!     Call the subroutine for the whole recrossing calculation!
!
!     check if the calculation has been done already before
!
call mpi_barrier(mpi_comm_world,ierr)
recross_calc=.true.
inquire(file="recross_finished", exist=dont_del)
if (.not. dont_del) then
  ! if (rank .eq. 0) then
      if (recross_mpi) then
         call recross(rank,psize,dt,xi_barrier,energy_ts,kappa)
      else 
         if (rank .eq. 0) then
            call recross_serial(rank,dt,xi_barrier,energy_ts,kappa)  ! serial version: recross_serial.f90
         end if
      end if
!
!     Avoid strange values of the recrossing coefficient: If the value is too
!     low (2% or less) , set it to 1.0 and print warning message
!
   if (rank .eq. 0) then
      if (kappa .lt. 0.02d0) then
         write(15,*) 
         write(15,*) "Warning! The computed recrossing coefficient is very low!"
         write(15,*) "The value is just:",kappa
         write(15,*) "In order to avoid strange k(T) results, the kappa value will"
         write(15,*) "be set to 1.0! Check your calculation settings or contact"
         write(15,*) "Julien Steffen if this warning occurs!"
         write(15,*) 
         write(*,*) 
         write(*,*) "Warning! The computed recrossing coefficient is very low!"
         write(*,*) "The value is just:",kappa
         write(*,*) "In order to avoid strange k(T) results, the kappa value will"
         write(*,*) "be set to 1.0! Check your calculation settings or contact"
         write(*,*) "Julien Steffen if this warning occurs!"
         write(*,*)
         kappa=1.0d0
      end if
   end if

!
!     Print the calculated recrossing factor after finished calculation!
!
   if (rank .eq. 0) then
      write(15,*) "The recrossing factor has been calculated successfully!"
      write(15,*) "     Its final value is:"
      write(15,'(a,f12.8)') "        ", kappa
      write(*,*) "The recrossing factor has been calculated successfully!"
      write(*,*) "     Its final value is:"
      write(*,'(a,f12.8)') "        ", kappa
   end if
else 
   if (rank .eq. 0) then
      write(15,*)
      write(15,*) "The recrossing factor was calculated in a previous run!"
      write(15,*) "Delete the file 'recross_finished' first if you want to"
      write(15,*) "do it once again!"
      write(*,*)
      write(*,*) "The recrossing factor was calculated in a previous run!"
      write(*,*) "Delete the file 'recross_finished' first if you want to"
      write(*,*) "do it once again!"
   end if
   open(unit=33,file="recross_finished",status="old")
   read(33,*) kappa
   close(33)
   if (rank .eq. 0) then
      if (kappa .lt. 0.002d0) then
         write(15,*)
         write(15,*) "Warning! The computed recrossing coefficient is very low!"
         write(15,*) "The value is just:",kappa
         write(15,*) "In order to avoid strange k(T) results, the kappa value will"
         write(15,*) "be set to 1.0! Check your calculation settings or contact"
         write(15,*) "Julien Steffen if this warning occurs!"
         write(15,*)
         write(*,*)
         write(*,*) "Warning! The computed recrossing coefficient is very low!"
         write(*,*) "The value is just:",kappa
         write(*,*) "In order to avoid strange k(T) results, the kappa value will"
         write(*,*) "be set to 1.0! Check your calculation settings or contact"
         write(*,*) "Julien Steffen if this warning occurs!"
         write(*,*)
         kappa=1.0d0
      end if
   end if
end if
333 continue
recross_calc=.false.
call mpi_barrier(mpi_comm_world,ierr)
! --------------------------------------------------------!
!     CALCULATE THE RATE CONSTANT FOR THE REACTION
! --------------------------------------------------------!
if (rank .eq. 0) then
   write(15,*)
   write(15,*) "-------------------PART   5-------------------"
   write(15,*) "Calculate the final rate constant."
   write(15,*) "Apply the usual QTST formula with the recrossing "
   write(15,*) "correction prefactor."
   write(15,*) "----------------------------------------------"
   write(*,*)
   write(*,*) "-------------------PART   5-------------------"
   write(*,*) "Calculate the final rate constant."
   write(*,*) "Apply the usual QTST formula with the recrossing "
   write(*,*) "correction prefactor."
   write(*,*) "----------------------------------------------"
end if

!
!     Calculate the integral of exp(beta W(s)) for the unimolecular 
!     rate constants 
!
if (rank .eq. 0) then
   pmf_int=0.d0
   if ((umbr_type .eq. "ATOM_SHIFT") .or. (umbr_type .eq. "CYCLOREVER") .or. &
       & (umbr_type .eq. "REARRANGE") .or. (umbr_type .eq. "DECOM_1BOND") .or.&
       & (umbr_type .eq. "ELIMINATION")) then
      pmf_int=0.d0
      do i=minlocate,maxlocate
         pmf_int=pmf_int+exp(-beta*pmf(i))
      end do
!
!     Determine the length of the total reaction path between reactants and TS
!     if the atom_shift coordinate is used     

      if (umbr_type .eq. "ATOM_SHIFT") then
         if (shift_coord .lt. 4) then
            pmf_int=pmf_int*bin_size*abs(abs(shift_hi)-abs(shift_lo))
         else if (shift_coord .ge. 4) then
            pmf_int=pmf_int*bin_size*sqrt(abs(abs(shift_hi)-abs(shift_lo))**2+ &
                   & abs(abs(shift2_hi)-abs(shift2_lo))**2)
         end if
      else 
         pmf_int=pmf_int*bin_size
      end if
   end if
end if
!
!    Measure the needed time the rate constant calculation
!
if (rank .eq. 0) then
   call cpu_time(time(7))
end if

!
!    define some needed parameters
!    --> The minimum and maximum of the free energy surface 
!    new: the minimum is now the 
!

call mpi_barrier(mpi_comm_world,ierr)
if (rank .eq. 0) then
   pmf_max=pmf(pmf_maxlocate)
   pmf_min=pmf(minlocate)
   call calc_k_t(pmf_max,pmf_min,xi_pmf_max,xi_minimum,kappa,pmf_int)
end if

!
!     If an external PES has been used, remove the folders for each for each MPI rank
!
if (call_ext) then
   if (rank .lt. 10) then
      write(rank_char,'(i1)') rank
   else if (rank .lt. 100) then
      write(rank_char,'(i2)') rank
   else if (rank .lt. 1000) then
      write(rank_char,'(i3)') rank
   else
      write(rank_char,'(i4)') rank
   end if

   inquire(file="rank"//rank_char, exist=dont_del)
   if (dont_del) then
      call system("rm -r  rank"//trim(rank_char))
   end if
end if


call chdir("..")
call mpi_barrier(mpi_comm_world,ierr)

!
!     If an external PES has been used, remove the folders for each for each MPI rank
!
if (call_ext) then
   if (rank .lt. 10) then
      write(rank_char,'(i1)') rank
   else if (rank .lt. 100) then
      write(rank_char,'(i2)') rank
   else if (rank .lt. 1000) then
      write(rank_char,'(i3)') rank
   else 
      write(rank_char,'(i4)') rank
   end if
   inquire(file="rank"//rank_char, exist=dont_del)
   if (dont_del) then
      call system("rm -r  rank"//trim(rank_char))
   end if
end if


!
!
!    Determine the total time of calculation
!
if (rank .eq. 0) then
   call cpu_time(time(8))
end if
!
!    Print out the calculation time partitioning and the final messages
!    Print out time measuring for better informations 
!


tot_time=int(time(8)-time(1))
ndays=tot_time/86400
nhours=(tot_time-86400*ndays)/3600
nminutes=(tot_time-86400*ndays-3600*nhours)/60
nseconds=tot_time-86400*ndays-3600*nhours-60*nminutes

if (rank .eq. 0) then
   write(15,*)
   write(15,*) " Timings: " 
   write(15,*) " ----------"
   write(15,'(A, F12.3, A)') " Read in of settings and initialization: ",time(2)-time(1)," s."
   write(15,'(A, F12.3, A)') " Initial structure generation:           ",time(3)-time(2)," s."
   write(15,'(A, F12.3, A)') " Umbrella equilibration and samplings:   ",time(4)-time(3)," s."
   write(15,'(A, F12.3, A)') " Evaluation of sampling results:         ",time(5)-time(4)," s."
   write(15,'(A, F12.3, A)') " Calculation of the free energy surface: ",time(6)-time(5)," s."
   write(15,'(A, F12.3, A)') " Recrossing factor calculation:          ",time(7)-time(6)," s."
   write(15,'(A, F12.3, A)') " Final rate constant calculation:        ",time(8)-time(7)," s."
   write(15,*)
   write(15,'(A, F12.3, A)') " The calculation needed a total time of  ",time(8)-time(1)," seconds."
   write(15,'(A, I6,A,I2,A,I2,A,I2,A)') " These are: ",ndays," days, ",nhours," hours, ",nminutes,&
             & " minutes and ",nseconds," seconds."
   write(15,*)
   write(*,*)
   write(*,*) " Timings: "
   write(*,*) " ----------"
   write(*,'(A, F12.3, A)') " Read in of settings and initialization:  ",time(2)-time(1)," s."
   write(*,'(A, F12.3, A)') " Initial structure generation:            ",time(3)-time(2)," s."
   write(*,'(A, F12.3, A)') " Umbrella equilibration and samplings:    ",time(4)-time(3)," s."
   write(*,'(A, F12.3, A)') " Evaluation of sampling results:          ",time(5)-time(4)," s."
   write(*,'(A, F12.3, A)') " Calculation of the free energy surface:  ",time(6)-time(5)," s."
   write(*,'(A, F12.3, A)') " Recrossing factor calculation:           ",time(7)-time(6)," s."
   write(*,'(A, F12.3, A)') " Final rate constant calculation:         ",time(8)-time(7)," s."
   write(*,*)
   write(*,'(A, F12.3, A)') " The calculation needed a total time of   ",time(8)-time(1)," seconds."
   write(*,'(A, I6,A,I2,A,I2,A,I2,A)') " These are: ",ndays," days, ",nhours," hours, ",nminutes,&
             & " minutes and ",nseconds," seconds."
   write(*,*)

   write(15,*) " -.-. .- .-. .- -.-. .- .-.. "
   write(15,*) "CARACAL rate constant calculation successfully finished!"
   write(15,*) 
   write(15,*) "exit time:"
   call timestamp ()

   write(*,*) " -.-. .- .-. .- -.-. .- .-.. "
   write(*,*) "Informations printed to calc_rate.log!"
   write(*,*) "Other results are stored into folder ",foldername
   write(*,*) "CARACAL rate constant calculation successfully finished!"
   write(*,*) 
end if
!
!     close the logfile with informations about the calculation!
!
close(15)
call mpi_barrier(mpi_comm_world,ierr)
!stop "Bug in MPI finalize"
call mpi_finalize(ierr)

end program calc_rate

